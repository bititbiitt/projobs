module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/projobs/src/app/api/post-job/parse-doc/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/projobs/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$mammoth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/projobs/node_modules/mammoth/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$pdf$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/projobs/node_modules/pdf-parse/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$os__$5b$external$5d$__$28$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/os [external] (os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/util [external] (util, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$child_process__$5b$external$5d$__$28$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/child_process [external] (child_process, cjs)");
;
;
;
;
;
;
;
;
;
const exec = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["promisify"])(__TURBOPACK__imported__module__$5b$externals$5d2f$child_process__$5b$external$5d$__$28$child_process$2c$__cjs$29$__["default"].exec);
// simple id generator for parse items
const genId = ()=>`${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 9)}`;
async function POST(request) {
    try {
        const body = await request.json();
        const { name, mime, data, versionId } = body;
        const b = Buffer.from(data, 'base64');
        const lower = String(name || '').toLowerCase();
        let text = '';
        let html = '';
        if (lower.endsWith('.docx') || mime === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            const result = await __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$mammoth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].convertToHtml({
                buffer: b
            });
            html = result.value;
            text = stripHtml(result.value);
        } else if (lower.endsWith('.pdf') || mime === 'application/pdf') {
            const pdf = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$pdf$2d$parse$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(b);
            text = pdf.text || '';
        } else {
            // fallback: try to decode as utf8 text
            text = b.toString('utf8');
        }
        // For PDFs, run OCR automatically (preferred over raw extracted text when available)
        let finalText = text || html || '';
        if (mime === 'application/pdf' || lower.endsWith('.pdf')) {
            try {
                const ocrText = await tryOcrPdf(b);
                if (ocrText && ocrText.trim().length > 0) {
                    finalText = ocrText;
                }
            } catch (e) {
            // ignore OCR failure and continue with existing extracted text
            }
        }
        // run rule-based parser on extracted text/html
        const parsed = parseTextToQuestions(finalText || html || '');
        // compute overall confidence (average of item confidences)
        const confidence = parsed.length === 0 ? 0 : Math.max(0, Math.min(1, parsed.reduce((s, p)=>s + (p.__confidence || 0.7), 0) / parsed.length));
        // attempt to persist parse result in DB if Prisma is available
        let savedId = null;
        try {
            const mod = await __turbopack_context__.A("[externals]/@prisma/client [external] (@prisma/client, cjs, [project]/projobs/node_modules/@prisma/client, async loader)");
            const prisma = new mod.PrismaClient();
            // if no versionId provided, create a job_document_version record (minimal) so results can be linked
            let targetVersionId = versionId ?? null;
            if (!targetVersionId) {
                try {
                    const fileHash = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('sha256').update(b).digest('hex');
                    const created = await prisma.job_document_version.create({
                        data: {
                            doc_id: null,
                            version_num: 1,
                            blob_uri: null,
                            file_hash: fileHash,
                            file_type: mime ?? null,
                            file_size: b.length,
                            ocr_used: mime === 'application/pdf'
                        }
                    });
                    targetVersionId = created.id;
                } catch (inner) {
                // ignore version creation failure, continue to try to save parse result without version link
                }
            }
            const rec = await prisma.job_document_parse_result.create({
                data: {
                    version_id: targetVersionId ?? null,
                    parsed_data: parsed,
                    confidence: confidence || undefined,
                    parse_status: parsed.length > 0 ? 'ok' : 'partial',
                    model_version: 'rule-v1'
                }
            });
            savedId = rec.id;
            try {
                await prisma.$disconnect();
            } catch (e) {}
        } catch (e) {
        // Prisma not available or DB error — ignore but keep working
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            parsed,
            confidence,
            parseResultId: savedId,
            text,
            html
        });
    } catch (err) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$projobs$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: String(err)
        }, {
            status: 500
        });
    }
}
function stripHtml(html) {
    return html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
}
// RULE-BASED PARSER
function parseTextToQuestions(raw) {
    const out = [];
    const blocks = raw.split(/\n\s*\n+/).map((b)=>b.trim()).filter(Boolean).slice(0, 300);
    for (const blk of blocks){
        const lines = blk.split(/\r?\n/).map((l)=>l.trim()).filter(Boolean);
        if (lines.length === 0) continue;
        // header / question candidate is first line
        const first = lines[0];
        // detect options in following lines
        const optionLines = lines.slice(1).filter((l)=>/^([\-\u2022\*\dA-Za-z])[\).\-\s]/.test(l) || /^\s*[-•*]/.test(l));
        const options = optionLines.length > 0 ? optionLines.map((l)=>l.replace(/^([\-\u2022\*]|\d+[\).]|[A-Za-z][\).])\s*/, '').trim ? l.replace(/^([\-\u2022\*]|\d+[\).]|[A-Za-z][\).])\s*/, '').trim() : l) : [];
        // infer type
        let type = 'text';
        let confidence = 0.7;
        const lower = blk.toLowerCase();
        if (options.length >= 1) {
            // if options present and look like checkboxes (multiple markers) -> checkbox else radio
            const multiHints = optionLines.some((l)=>/checkbox|multiple/i.test(l) || /choose all/i.test(blk));
            type = multiHints ? 'checkbox' : 'radio';
            confidence = 0.85;
        } else if (/\bemail\b|@/.test(lower)) {
            type = 'email';
            confidence = 0.95;
        } else if (/\bphone\b|tel\b|\(\d{3}\)\s*\d{3}-\d{4}|\b\d{3}[\s.-]?\d{3}[\s.-]?\d{4}\b/.test(lower)) {
            type = 'phone';
            confidence = 0.9;
        } else if (/\b(date|dob|birth)\b|\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/.test(lower)) {
            type = 'date';
            confidence = 0.9;
        } else if (first.length > 120 || blk.split(/[\.\?\!]/).length > 3) {
            type = 'textarea';
            confidence = 0.75;
        } else if (/\?$/.test(first) || /^do you |^have you |^are you |^please provide /i.test(first)) {
            type = 'text';
            confidence = 0.8;
        }
        // detect required
        const required = /\*|required|must provide|mandatory/i.test(blk);
        // generate label (strip numbering)
        const label = first.replace(/^\s*(?:\d+[:.)\-]?|[A-Za-z][\).\-]?|[\-\u2022\*])\s*/, '').trim();
        const q = {
            id: genId(),
            label: label || first,
            type,
            options: options.length ? options : undefined,
            required,
            category: 'job',
            __confidence: confidence
        };
        out.push(q);
    }
    return out;
}
function looksLikeGarbled(s) {
    if (!s) return true;
    const cleaned = s.replace(/\s+/g, '');
    if (cleaned.length < 120) return true; // too short
    // compute fraction of non-alphanumeric (excluding common punctuation)
    const nonAlpha = (s.match(/[^\w\s\p{P}]/gu) || []).length;
    const ratio = nonAlpha / Math.max(1, s.length);
    return ratio > 0.15; // heuristic
}
async function tryOcrPdf(buffer) {
    // writes buffer to temp file, tries pdftoppm -> tesseract pipeline or ImageMagick -> tesseract
    const tmpDir = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdtempSync(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(__TURBOPACK__imported__module__$5b$externals$5d2f$os__$5b$external$5d$__$28$os$2c$__cjs$29$__["default"].tmpdir(), 'ocr-'));
    const pdfPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(tmpDir, 'doc.pdf');
    __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(pdfPath, buffer);
    const outPrefix = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(tmpDir, 'page');
    try {
        // try pdftoppm
        try {
            await exec(`pdftoppm -png ${escapePath(pdfPath)} ${escapePath(outPrefix)}`);
        } catch (e) {
            // fallback to imagemagick 'magick' or 'convert'
            try {
                await exec(`magick -density 300 ${escapePath(pdfPath)} ${escapePath(outPrefix)}.png`);
            } catch (e2) {
                try {
                    await exec(`convert -density 300 ${escapePath(pdfPath)} ${escapePath(outPrefix)}.png`);
                } catch (e3) {
                    throw new Error('No PDF->PNG tool available');
                }
            }
        }
        // collect generated png files
        const files = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readdirSync(tmpDir).filter((f)=>f.endsWith('.png')).map((f)=>__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(tmpDir, f)).sort();
        if (files.length === 0) throw new Error('No images produced for OCR');
        let fullText = '';
        for (const img of files){
            try {
                // run tesseract to stdout
                const { stdout } = await exec(`tesseract ${escapePath(img)} stdout -l eng`);
                fullText += '\n\n' + stdout;
            } catch (e) {
            // tesseract failed for this image, continue
            }
        }
        // cleanup
        try {
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].rmSync(tmpDir, {
                recursive: true,
                force: true
            });
        } catch (e) {}
        return fullText.trim();
    } catch (err) {
        try {
            __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].rmSync(tmpDir, {
                recursive: true,
                force: true
            });
        } catch (e) {}
        throw err;
    }
}
function escapePath(p) {
    // simple quoting for paths with spaces
    if (p.indexOf(' ') >= 0) return `"${p}"`;
    return p;
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__eb8dd242._.js.map