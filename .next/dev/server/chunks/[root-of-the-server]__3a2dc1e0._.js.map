{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ILT/projobs/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\nimport { Pool } from 'pg';\r\nimport { PrismaPg } from '@prisma/adapter-pg';\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n};\r\n\r\nconst prismaClientSingleton = () => {\r\n  const connectionString = process.env.DATABASE_URL;\r\n  const pool = new Pool({ connectionString });\r\n  const adapter = new PrismaPg(pool);\r\n  \r\n  return new PrismaClient({\r\n    log: [\"query\"],\r\n    adapter,\r\n  });\r\n};\r\n\r\nexport const db =\r\n  globalForPrisma.prisma ??\r\n  prismaClientSingleton();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,wBAAwB;IAC5B,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;IACjD,MAAM,OAAO,IAAI,gKAAI,CAAC;QAAE;IAAiB;IACzC,MAAM,UAAU,IAAI,oLAAQ,CAAC;IAE7B,OAAO,IAAI,iNAAY,CAAC;QACtB,KAAK;YAAC;SAAQ;QACd;IACF;AACF;AAEO,MAAM,KACX,gBAAgB,MAAM,IACtB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ILT/projobs/src/app/api/search/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { MeiliSearch } from 'meilisearch';\r\nimport { db } from '@/lib/db';\r\n\r\n// Initialize Meilisearch Client\r\n// Note: In production, use process.env.MEILISEARCH_HOST and process.env.MEILISEARCH_KEY\r\nconst client = new MeiliSearch({\r\n  host: process.env.MEILISEARCH_HOST || 'http://127.0.0.1:7700',\r\n  apiKey: process.env.MEILISEARCH_KEY || 'masterKey',\r\n});\r\n\r\nconst INDEX_NAME = 'projobs_search';\r\n\r\nexport async function GET(request: Request) {\r\n  const { searchParams } = new URL(request.url);\r\n  const taxonomy = searchParams.get('taxonomy');\r\n  const query = searchParams.get('q');\r\n\r\n  if (taxonomy === 'categories') {\r\n    const cats = await (db as any)?.job_category?.findMany?.({ select: { name: true, category_id: true } }) ?? [];\r\n    return NextResponse.json(cats.map((c: any) => ({ name: c.name, id: c.category_id })));\r\n  }\r\n\r\n  if (taxonomy === 'functions') {\r\n    const funcs = await (db as any)?.job_function?.findMany?.({ select: { name: true, function_id: true } }) ?? [];\r\n    return NextResponse.json(funcs.map((f: any) => ({ name: f.name, id: f.function_id })));\r\n  }\r\n\r\n  if (taxonomy === 'locations') {\r\n    // TODO: Implement locations taxonomy\r\n    return NextResponse.json([]);\r\n  }\r\n\r\n  if (!query) {\r\n    return NextResponse.json([]);\r\n  }\r\n\r\n  try {\r\n    const index = client.index(INDEX_NAME);\r\n\r\n    // --- AUTO-SEEDING FOR DEMO PURPOSES ---\r\n    // In a real app, you would run a seeding script separately.\r\n    // Here, we check if the index exists/has documents on every search to ensure it works out-of-the-box.\r\n    try {\r\n      const stats = await index.getStats();\r\n      if (stats.numberOfDocuments === 0) {\r\n        await seedData(index);\r\n      }\r\n    } catch (e: any) {\r\n      if (e.code === 'index_not_found') {\r\n        await client.createIndex(INDEX_NAME, { primaryKey: 'id' });\r\n        await seedData(index);\r\n      }\r\n    }\r\n    // --------------------------------------\r\n\r\n    const runSearch = async () => index.search(query, {\r\n      limit: 100, // Increased limit to ensure we get enough mixed results to sort\r\n      attributesToRetrieve: ['text', 'type'],\r\n      attributesToSearchOn: ['text'],\r\n      showMatchesPosition: true,\r\n    });\r\n\r\n    let searchResults = await runSearch();\r\n\r\n    // If nothing comes back (stale/empty index), force a reseed once and retry\r\n    if (searchResults.hits.length === 0) {\r\n      await seedData(index);\r\n      searchResults = await runSearch();\r\n    }\r\n\r\n    console.log(`Query: \"${query}\" -> Hits: ${searchResults.hits.length}`);\r\n\r\n    // Return objects with text and type\r\n    const results = searchResults.hits\r\n      .map((hit: any) => ({ \r\n        text: hit.text, \r\n        type: hit.type || 'unknown' \r\n      }))\r\n      .filter((item: any) => typeof item.text === 'string' && item.text.length > 0);\r\n    \r\n    return NextResponse.json(results);\r\n\r\n  } catch (error) {\r\n    console.error(\"Meilisearch Error:\", error);\r\n    // Fallback: If Meilisearch is down, return empty to prevent UI crash\r\n    return NextResponse.json([]);\r\n  }\r\n}\r\n\r\nasync function seedData(index: any) {\r\n  console.log(\"Seeding Meilisearch Index from Database...\");\r\n  const catClient = (db as any)?.jobCategory;\r\n  const funcClient = (db as any)?.jobFunction;\r\n  const categories = catClient?.findMany ? await catClient.findMany() : [];\r\n  const functions = funcClient?.findMany ? await funcClient.findMany() : [];\r\n  const jobs = await db.job.findMany();\r\n\r\n  // Transform data into flat searchable objects\r\n  const categoryDocs = categories.map((c: any) => ({\r\n    id: `cat-${c.category_id}`,\r\n    text: c.name,\r\n    type: 'category'\r\n  }));\r\n\r\n  const functionDocs = functions.map((f: any) => ({\r\n    id: `func-${f.function_id}`,\r\n    text: f.name,\r\n    type: 'function'\r\n  }));\r\n\r\n  const jobDocs = jobs.map((j) => ({\r\n    id: `job-${j.id}`,\r\n    text: j.title || '',\r\n    company: (j.metadata && (j.metadata as any).company) || null,\r\n    type: 'job'\r\n  })).filter(doc => doc.text.length > 0);\r\n  \r\n  // Also index company names separately for better discovery\r\n  const companyDocs = Array.from(new Set(jobs.map(j => (j.metadata && (j.metadata as any).company) || null)))\r\n    .filter(Boolean)\r\n    .map((c, i) => ({\r\n       id: `comp-${i}`,\r\n       text: c,\r\n       type: 'company'\r\n    }));\r\n\r\n  const organizationDocs = Array.from(new Set(jobs.map(j => (j.metadata && (j.metadata as any).organization) || null)))\r\n    .filter(Boolean)\r\n    .map((a, i) => ({\r\n       id: `organization-${i}`,\r\n       text: a,\r\n       type: 'organization'\r\n    }));\r\n\r\n  const documents = [...categoryDocs, ...functionDocs, ...jobDocs, ...companyDocs, ...organizationDocs];\r\n\r\n  const task = await index.addDocuments(documents);\r\n  console.log(`Seeding task enqueued: ${task.taskUid}`);\r\n  \r\n  // Wait for the indexing to finish before searching (crucial for first-run experience)\r\n  await (client as any).waitForTask(task.taskUid);\r\n  console.log(`Seeding complete.`);\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;AAEA,gCAAgC;AAChC,wFAAwF;AACxF,MAAM,SAAS,IAAI,+KAAW,CAAC;IAC7B,MAAM,QAAQ,GAAG,CAAC,gBAAgB,IAAI;IACtC,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI;AACzC;AAEA,MAAM,aAAa;AAEZ,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,MAAM,QAAQ,aAAa,GAAG,CAAC;IAE/B,IAAI,aAAa,cAAc;QAC7B,MAAM,OAAO,MAAO,mIAAE,EAAU,cAAc,WAAW;YAAE,QAAQ;gBAAE,MAAM;gBAAM,aAAa;YAAK;QAAE,MAAM,EAAE;QAC7G,OAAO,2JAAY,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,IAAW,CAAC;gBAAE,MAAM,EAAE,IAAI;gBAAE,IAAI,EAAE,WAAW;YAAC,CAAC;IACpF;IAEA,IAAI,aAAa,aAAa;QAC5B,MAAM,QAAQ,MAAO,mIAAE,EAAU,cAAc,WAAW;YAAE,QAAQ;gBAAE,MAAM;gBAAM,aAAa;YAAK;QAAE,MAAM,EAAE;QAC9G,OAAO,2JAAY,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,IAAW,CAAC;gBAAE,MAAM,EAAE,IAAI;gBAAE,IAAI,EAAE,WAAW;YAAC,CAAC;IACrF;IAEA,IAAI,aAAa,aAAa;QAC5B,qCAAqC;QACrC,OAAO,2JAAY,CAAC,IAAI,CAAC,EAAE;IAC7B;IAEA,IAAI,CAAC,OAAO;QACV,OAAO,2JAAY,CAAC,IAAI,CAAC,EAAE;IAC7B;IAEA,IAAI;QACF,MAAM,QAAQ,OAAO,KAAK,CAAC;QAE3B,yCAAyC;QACzC,4DAA4D;QAC5D,sGAAsG;QACtG,IAAI;YACF,MAAM,QAAQ,MAAM,MAAM,QAAQ;YAClC,IAAI,MAAM,iBAAiB,KAAK,GAAG;gBACjC,MAAM,SAAS;YACjB;QACF,EAAE,OAAO,GAAQ;YACf,IAAI,EAAE,IAAI,KAAK,mBAAmB;gBAChC,MAAM,OAAO,WAAW,CAAC,YAAY;oBAAE,YAAY;gBAAK;gBACxD,MAAM,SAAS;YACjB;QACF;QACA,yCAAyC;QAEzC,MAAM,YAAY,UAAY,MAAM,MAAM,CAAC,OAAO;gBAChD,OAAO;gBACP,sBAAsB;oBAAC;oBAAQ;iBAAO;gBACtC,sBAAsB;oBAAC;iBAAO;gBAC9B,qBAAqB;YACvB;QAEA,IAAI,gBAAgB,MAAM;QAE1B,2EAA2E;QAC3E,IAAI,cAAc,IAAI,CAAC,MAAM,KAAK,GAAG;YACnC,MAAM,SAAS;YACf,gBAAgB,MAAM;QACxB;QAEA,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,MAAM,WAAW,EAAE,cAAc,IAAI,CAAC,MAAM,EAAE;QAErE,oCAAoC;QACpC,MAAM,UAAU,cAAc,IAAI,CAC/B,GAAG,CAAC,CAAC,MAAa,CAAC;gBAClB,MAAM,IAAI,IAAI;gBACd,MAAM,IAAI,IAAI,IAAI;YACpB,CAAC,GACA,MAAM,CAAC,CAAC,OAAc,OAAO,KAAK,IAAI,KAAK,YAAY,KAAK,IAAI,CAAC,MAAM,GAAG;QAE7E,OAAO,2JAAY,CAAC,IAAI,CAAC;IAE3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,qEAAqE;QACrE,OAAO,2JAAY,CAAC,IAAI,CAAC,EAAE;IAC7B;AACF;AAEA,eAAe,SAAS,KAAU;IAChC,QAAQ,GAAG,CAAC;IACZ,MAAM,YAAa,mIAAE,EAAU;IAC/B,MAAM,aAAc,mIAAE,EAAU;IAChC,MAAM,aAAa,WAAW,WAAW,MAAM,UAAU,QAAQ,KAAK,EAAE;IACxE,MAAM,YAAY,YAAY,WAAW,MAAM,WAAW,QAAQ,KAAK,EAAE;IACzE,MAAM,OAAO,MAAM,mIAAE,CAAC,GAAG,CAAC,QAAQ;IAElC,8CAA8C;IAC9C,MAAM,eAAe,WAAW,GAAG,CAAC,CAAC,IAAW,CAAC;YAC/C,IAAI,CAAC,IAAI,EAAE,EAAE,WAAW,EAAE;YAC1B,MAAM,EAAE,IAAI;YACZ,MAAM;QACR,CAAC;IAED,MAAM,eAAe,UAAU,GAAG,CAAC,CAAC,IAAW,CAAC;YAC9C,IAAI,CAAC,KAAK,EAAE,EAAE,WAAW,EAAE;YAC3B,MAAM,EAAE,IAAI;YACZ,MAAM;QACR,CAAC;IAED,MAAM,UAAU,KAAK,GAAG,CAAC,CAAC,IAAM,CAAC;YAC/B,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE;YACjB,MAAM,EAAE,KAAK,IAAI;YACjB,SAAS,AAAC,EAAE,QAAQ,IAAI,AAAC,EAAE,QAAQ,CAAS,OAAO,IAAK;YACxD,MAAM;QACR,CAAC,GAAG,MAAM,CAAC,CAAA,MAAO,IAAI,IAAI,CAAC,MAAM,GAAG;IAEpC,2DAA2D;IAC3D,MAAM,cAAc,MAAM,IAAI,CAAC,IAAI,IAAI,KAAK,GAAG,CAAC,CAAA,IAAK,AAAC,EAAE,QAAQ,IAAI,AAAC,EAAE,QAAQ,CAAS,OAAO,IAAK,QACjG,MAAM,CAAC,SACP,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;YACb,IAAI,CAAC,KAAK,EAAE,GAAG;YACf,MAAM;YACN,MAAM;QACT,CAAC;IAEH,MAAM,mBAAmB,MAAM,IAAI,CAAC,IAAI,IAAI,KAAK,GAAG,CAAC,CAAA,IAAK,AAAC,EAAE,QAAQ,IAAI,AAAC,EAAE,QAAQ,CAAS,YAAY,IAAK,QAC3G,MAAM,CAAC,SACP,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;YACb,IAAI,CAAC,aAAa,EAAE,GAAG;YACvB,MAAM;YACN,MAAM;QACT,CAAC;IAEH,MAAM,YAAY;WAAI;WAAiB;WAAiB;WAAY;WAAgB;KAAiB;IAErG,MAAM,OAAO,MAAM,MAAM,YAAY,CAAC;IACtC,QAAQ,GAAG,CAAC,CAAC,uBAAuB,EAAE,KAAK,OAAO,EAAE;IAEpD,sFAAsF;IACtF,MAAM,AAAC,OAAe,WAAW,CAAC,KAAK,OAAO;IAC9C,QAAQ,GAAG,CAAC,CAAC,iBAAiB,CAAC;AACjC"}}]
}